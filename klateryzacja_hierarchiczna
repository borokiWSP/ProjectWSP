UWAGA! Potrzebowałam tutaj klas dlatego pracowałam na danych, które uzyskujemy z main zmodyfikowanego przez Anatę. 

# ----------------------------------------------------------
# Klasteryzacja hierarchiczna z mapą ciepła - Martyna 
# ----------------------------------------------------------

klateryzacja_hierarchiczna <- function (dane_po_normalizacji) {
  
  
  if (!require("gplots")) {
    install.packages("gplots")
  }
  if (!require("RColorBrewer")) {
    install.packages("RColorBrewer")
  }
  
  # ----------------------------------------------------------
  # Krok 1: Przygotowanie danych
  # ----------------------------------------------------------
  
  #Według ustaleń biorę tylko klasę ADENO i NORMAL
  ktory_adano_normal<- dane_po_normalizacji@phenoData@data[["ADENO"]] %in% c("ADENO", "NORMAL") #sprawdza, który plik ma klasę anedo lub normal
  adeno_normal <- dane_po_normalizacji[, ktory_adano_normal] #tworze nową zmienną w której zapisane są tylko pliki z klasy adeno lub normal
  
  #określam WARIANCJĘ dla wszystkich genów w próbkach i wybieram 
  #200 genów o największej zmienności. (odrzucam te o najmniejsze wartości)
  adeno_normal_wariancja <- rowVars(exprs(adeno_normal)) #Wariancja 
  top200 <- names(sort(adeno_normal_wariancja, decreasing = TRUE))[1:200] #200 genów o największej zmienności
  adeno_normal_200genow <- adeno_normal[top200, ] # nowa zmienna z wybranymi 200 genami 
  
  # ----------------------------------------------------------
  # Krok 2: Metryka odległości
  # ----------------------------------------------------------
  
  #funkcja odległosci 
  dist_cor <- function(x) {
    as.dist(1 - cor(t(x), method = "pearson"))
  }
  
  # ----------------------------------------------------------
  # Krok 3: Metoda klasteryzacji 
  # ----------------------------------------------------------
  
  # funkcja klasteryzacji 
  clus_wd2 <- function(x) {
    hclust(x, method = "ward.D2")
  }
  
  # ----------------------------------------------------------
  # Krok 4: Mapa ceipła dla mikromacierzy
  # ----------------------------------------------------------
  # zielony to geny 'down-regulated'
  # czarny to geny neutralne (bez większych zmian w ekspresji)
  # czerwony geny 'up-regulated' 
  kolory <- colorRampPalette(c("green", "black", "red"))(n = 100) #wybieram kolory do heatmapy
  
  #Definiowanie kolorów w pasku przynależności do klas- pierwszy "" to klasa dla której pasek będzie o kolorze 
  #zdefiniowanym w drugim "", trzeci "" to kolor klasy niezdefiniowanej (normal)
  klasy <- ifelse(adeno_normal_200genow@phenoData@data[["ADENO"]] == "ADENO","gray80" ,"gray40")
  
  heatmap.2(exprs(adeno_normal_200genow), 
            #klasteryzacja
            distfun = dist_cor, 
            hclust = clus_wd2,
            
            # skalowanie sprawiające, że poszczególne geny będą w rzędach scaling 
            scale = "row",
            
            #kolory heatmapy
            col = kolory,
            
            # podpisy kolumn - bez określenia kolumn pojawia się nazwa pliku CEL
            # w zmienionej wersji może pojawić się: adeno_normal_200genow@phenoData@data[["AD10"]]
            #lub adeno_normal_200genow@phenoData@data[["ADA10T1_A389_7"]]. Ja wybrałam pierwszą opcję 
            #czyli "simple_annotation" bo wydawało mi się to bardziej przejrzyste
            labCol=(adeno_normal_200genow@phenoData@data[["AD10"]]),
            
            # pasek przynależności do klas
            ColSideColors = klasy, 
            
            # sprawia, że mamy ładą heatmapę a nie histogramy dla każdej z danych
            trace = "none",
            density.info = "none")

}

